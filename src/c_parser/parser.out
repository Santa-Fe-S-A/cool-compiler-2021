Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    chunkComment
    lineComment
    newline
    space
    tab

Grammar

Rule 0     S' -> program
Rule 1     program -> class_list
Rule 2     class_list -> def_class
Rule 3     class_list -> def_class class_list
Rule 4     def_class -> class type ocur feature_list ccur semi
Rule 5     def_class -> class type inherits type ocur feature_list ccur semi
Rule 6     feature_list -> def_attr feature_list
Rule 7     feature_list -> def_func feature_list
Rule 8     feature_list -> <empty>
Rule 9     def_attr -> id colon type semi
Rule 10    def_attr -> id colon type assignArrow expr semi
Rule 11    def_func -> id opar arg_list cpar colon type ocur expr ccur semi
Rule 12    arg_list -> non_empty_arg_list
Rule 13    arg_list -> <empty>
Rule 14    non_empty_arg_list -> arg
Rule 15    non_empty_arg_list -> arg comma non_empty_arg_list
Rule 16    arg -> id colon type
Rule 17    param_list -> expr_list
Rule 18    param_list -> <empty>
Rule 19    expr_list -> expr
Rule 20    expr_list -> expr comma expr_list
Rule 21    chunk -> expr semi
Rule 22    chunk -> expr semi chunk
Rule 23    expr -> id assignArrow expr
Rule 24    expr -> expr dot id opar param_list cpar
Rule 25    expr -> expr arroba type dot id opar param_list cpar
Rule 26    expr -> id opar param_list cpar
Rule 27    expr -> if expr then expr else expr fi
Rule 28    expr -> while expr loop expr pool
Rule 29    expr -> ocur chunk ccur
Rule 30    expr -> let decl_list in expr
Rule 31    expr -> case expr of case_list esac
Rule 32    expr -> new type
Rule 33    expr -> isvoid expr
Rule 34    expr -> expr plus expr
Rule 35    expr -> expr minus expr
Rule 36    expr -> expr star expr
Rule 37    expr -> expr div expr
Rule 38    expr -> expr equal expr
Rule 39    expr -> expr lneq expr
Rule 40    expr -> expr leq expr
Rule 41    expr -> complement expr
Rule 42    expr -> not expr
Rule 43    expr -> opar expr cpar
Rule 44    expr -> id
Rule 45    expr -> number
Rule 46    expr -> string
Rule 47    expr -> true
Rule 48    expr -> false
Rule 49    decl_list -> decl
Rule 50    decl_list -> decl comma decl_list
Rule 51    decl -> id colon type
Rule 52    decl -> id colon type assignArrow expr
Rule 53    case_list -> id colon type rArrow expr semi
Rule 54    case_list -> id colon type rArrow expr semi case_list

Terminals, with rules where they appear

arroba               : 25
assignArrow          : 10 23 52
case                 : 31
ccur                 : 4 5 11 29
chunkComment         : 
class                : 4 5
colon                : 9 10 11 16 51 52 53 54
comma                : 15 20 50
complement           : 41
cpar                 : 11 24 25 26 43
div                  : 37
dot                  : 24 25
else                 : 27
equal                : 38
error                : 
esac                 : 31
false                : 48
fi                   : 27
id                   : 9 10 11 16 23 24 25 26 44 51 52 53 54
if                   : 27
in                   : 30
inherits             : 5
isvoid               : 33
leq                  : 40
let                  : 30
lineComment          : 
lneq                 : 39
loop                 : 28
minus                : 35
new                  : 32
newline              : 
not                  : 42
number               : 45
ocur                 : 4 5 11 29
of                   : 31
opar                 : 11 24 25 26 43
plus                 : 34
pool                 : 28
rArrow               : 53 54
semi                 : 4 5 9 10 11 21 22 53 54
space                : 
star                 : 36
string               : 46
tab                  : 
then                 : 27
true                 : 47
type                 : 4 5 5 9 10 11 16 25 32 51 52 53 54
while                : 28

Nonterminals, with rules where they appear

arg                  : 14 15
arg_list             : 11
case_list            : 31 54
chunk                : 22 29
class_list           : 1 3
decl                 : 49 50
decl_list            : 30 50
def_attr             : 6
def_class            : 2 3
def_func             : 7
expr                 : 10 11 19 20 21 22 23 24 25 27 27 27 28 28 30 31 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 42 43 52 53 54
expr_list            : 17 20
feature_list         : 4 5 6 7
non_empty_arg_list   : 12 15
param_list           : 24 25 26
program              : 0

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class_list
    (2) class_list -> . def_class
    (3) class_list -> . def_class class_list
    (4) def_class -> . class type ocur feature_list ccur semi
    (5) def_class -> . class type inherits type ocur feature_list ccur semi

    class           shift and go to state 4

    program                        shift and go to state 1
    class_list                     shift and go to state 2
    def_class                      shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class_list .

    $end            reduce using rule 1 (program -> class_list .)


state 3

    (2) class_list -> def_class .
    (3) class_list -> def_class . class_list
    (2) class_list -> . def_class
    (3) class_list -> . def_class class_list
    (4) def_class -> . class type ocur feature_list ccur semi
    (5) def_class -> . class type inherits type ocur feature_list ccur semi

    $end            reduce using rule 2 (class_list -> def_class .)
    class           shift and go to state 4

    def_class                      shift and go to state 3
    class_list                     shift and go to state 5

state 4

    (4) def_class -> class . type ocur feature_list ccur semi
    (5) def_class -> class . type inherits type ocur feature_list ccur semi

    type            shift and go to state 6


state 5

    (3) class_list -> def_class class_list .

    $end            reduce using rule 3 (class_list -> def_class class_list .)


state 6

    (4) def_class -> class type . ocur feature_list ccur semi
    (5) def_class -> class type . inherits type ocur feature_list ccur semi

    ocur            shift and go to state 7
    inherits        shift and go to state 8


state 7

    (4) def_class -> class type ocur . feature_list ccur semi
    (6) feature_list -> . def_attr feature_list
    (7) feature_list -> . def_func feature_list
    (8) feature_list -> .
    (9) def_attr -> . id colon type semi
    (10) def_attr -> . id colon type assignArrow expr semi
    (11) def_func -> . id opar arg_list cpar colon type ocur expr ccur semi

    ccur            reduce using rule 8 (feature_list -> .)
    id              shift and go to state 12

    feature_list                   shift and go to state 9
    def_attr                       shift and go to state 10
    def_func                       shift and go to state 11

state 8

    (5) def_class -> class type inherits . type ocur feature_list ccur semi

    type            shift and go to state 13


state 9

    (4) def_class -> class type ocur feature_list . ccur semi

    ccur            shift and go to state 14


state 10

    (6) feature_list -> def_attr . feature_list
    (6) feature_list -> . def_attr feature_list
    (7) feature_list -> . def_func feature_list
    (8) feature_list -> .
    (9) def_attr -> . id colon type semi
    (10) def_attr -> . id colon type assignArrow expr semi
    (11) def_func -> . id opar arg_list cpar colon type ocur expr ccur semi

    ccur            reduce using rule 8 (feature_list -> .)
    id              shift and go to state 12

    def_attr                       shift and go to state 10
    feature_list                   shift and go to state 15
    def_func                       shift and go to state 11

state 11

    (7) feature_list -> def_func . feature_list
    (6) feature_list -> . def_attr feature_list
    (7) feature_list -> . def_func feature_list
    (8) feature_list -> .
    (9) def_attr -> . id colon type semi
    (10) def_attr -> . id colon type assignArrow expr semi
    (11) def_func -> . id opar arg_list cpar colon type ocur expr ccur semi

    ccur            reduce using rule 8 (feature_list -> .)
    id              shift and go to state 12

    def_func                       shift and go to state 11
    feature_list                   shift and go to state 16
    def_attr                       shift and go to state 10

state 12

    (9) def_attr -> id . colon type semi
    (10) def_attr -> id . colon type assignArrow expr semi
    (11) def_func -> id . opar arg_list cpar colon type ocur expr ccur semi

    colon           shift and go to state 17
    opar            shift and go to state 18


state 13

    (5) def_class -> class type inherits type . ocur feature_list ccur semi

    ocur            shift and go to state 19


state 14

    (4) def_class -> class type ocur feature_list ccur . semi

    semi            shift and go to state 20


state 15

    (6) feature_list -> def_attr feature_list .

    ccur            reduce using rule 6 (feature_list -> def_attr feature_list .)


state 16

    (7) feature_list -> def_func feature_list .

    ccur            reduce using rule 7 (feature_list -> def_func feature_list .)


state 17

    (9) def_attr -> id colon . type semi
    (10) def_attr -> id colon . type assignArrow expr semi

    type            shift and go to state 21


state 18

    (11) def_func -> id opar . arg_list cpar colon type ocur expr ccur semi
    (12) arg_list -> . non_empty_arg_list
    (13) arg_list -> .
    (14) non_empty_arg_list -> . arg
    (15) non_empty_arg_list -> . arg comma non_empty_arg_list
    (16) arg -> . id colon type

    cpar            reduce using rule 13 (arg_list -> .)
    id              shift and go to state 22

    arg_list                       shift and go to state 23
    non_empty_arg_list             shift and go to state 24
    arg                            shift and go to state 25

state 19

    (5) def_class -> class type inherits type ocur . feature_list ccur semi
    (6) feature_list -> . def_attr feature_list
    (7) feature_list -> . def_func feature_list
    (8) feature_list -> .
    (9) def_attr -> . id colon type semi
    (10) def_attr -> . id colon type assignArrow expr semi
    (11) def_func -> . id opar arg_list cpar colon type ocur expr ccur semi

    ccur            reduce using rule 8 (feature_list -> .)
    id              shift and go to state 12

    feature_list                   shift and go to state 26
    def_attr                       shift and go to state 10
    def_func                       shift and go to state 11

state 20

    (4) def_class -> class type ocur feature_list ccur semi .

    class           reduce using rule 4 (def_class -> class type ocur feature_list ccur semi .)
    $end            reduce using rule 4 (def_class -> class type ocur feature_list ccur semi .)


state 21

    (9) def_attr -> id colon type . semi
    (10) def_attr -> id colon type . assignArrow expr semi

    semi            shift and go to state 27
    assignArrow     shift and go to state 28


state 22

    (16) arg -> id . colon type

    colon           shift and go to state 29


state 23

    (11) def_func -> id opar arg_list . cpar colon type ocur expr ccur semi

    cpar            shift and go to state 30


state 24

    (12) arg_list -> non_empty_arg_list .

    cpar            reduce using rule 12 (arg_list -> non_empty_arg_list .)


state 25

    (14) non_empty_arg_list -> arg .
    (15) non_empty_arg_list -> arg . comma non_empty_arg_list

    cpar            reduce using rule 14 (non_empty_arg_list -> arg .)
    comma           shift and go to state 31


state 26

    (5) def_class -> class type inherits type ocur feature_list . ccur semi

    ccur            shift and go to state 32


state 27

    (9) def_attr -> id colon type semi .

    id              reduce using rule 9 (def_attr -> id colon type semi .)
    ccur            reduce using rule 9 (def_attr -> id colon type semi .)


state 28

    (10) def_attr -> id colon type assignArrow . expr semi
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 34

state 29

    (16) arg -> id colon . type

    type            shift and go to state 49


state 30

    (11) def_func -> id opar arg_list cpar . colon type ocur expr ccur semi

    colon           shift and go to state 50


state 31

    (15) non_empty_arg_list -> arg comma . non_empty_arg_list
    (14) non_empty_arg_list -> . arg
    (15) non_empty_arg_list -> . arg comma non_empty_arg_list
    (16) arg -> . id colon type

    id              shift and go to state 22

    arg                            shift and go to state 25
    non_empty_arg_list             shift and go to state 51

state 32

    (5) def_class -> class type inherits type ocur feature_list ccur . semi

    semi            shift and go to state 52


state 33

    (23) expr -> id . assignArrow expr
    (26) expr -> id . opar param_list cpar
    (44) expr -> id .

    assignArrow     shift and go to state 53
    opar            shift and go to state 54
    semi            reduce using rule 44 (expr -> id .)
    dot             reduce using rule 44 (expr -> id .)
    arroba          reduce using rule 44 (expr -> id .)
    plus            reduce using rule 44 (expr -> id .)
    minus           reduce using rule 44 (expr -> id .)
    star            reduce using rule 44 (expr -> id .)
    div             reduce using rule 44 (expr -> id .)
    equal           reduce using rule 44 (expr -> id .)
    lneq            reduce using rule 44 (expr -> id .)
    leq             reduce using rule 44 (expr -> id .)
    cpar            reduce using rule 44 (expr -> id .)
    then            reduce using rule 44 (expr -> id .)
    loop            reduce using rule 44 (expr -> id .)
    of              reduce using rule 44 (expr -> id .)
    comma           reduce using rule 44 (expr -> id .)
    else            reduce using rule 44 (expr -> id .)
    pool            reduce using rule 44 (expr -> id .)
    ccur            reduce using rule 44 (expr -> id .)
    fi              reduce using rule 44 (expr -> id .)
    in              reduce using rule 44 (expr -> id .)


state 34

    (10) def_attr -> id colon type assignArrow expr . semi
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            shift and go to state 55
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 35

    (43) expr -> opar . expr cpar
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 65

state 36

    (27) expr -> if . expr then expr else expr fi
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 66

state 37

    (28) expr -> while . expr loop expr pool
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 67

state 38

    (29) expr -> ocur . chunk ccur
    (21) chunk -> . expr semi
    (22) chunk -> . expr semi chunk
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    chunk                          shift and go to state 68
    expr                           shift and go to state 69

state 39

    (30) expr -> let . decl_list in expr
    (49) decl_list -> . decl
    (50) decl_list -> . decl comma decl_list
    (51) decl -> . id colon type
    (52) decl -> . id colon type assignArrow expr

    id              shift and go to state 72

    decl_list                      shift and go to state 70
    decl                           shift and go to state 71

state 40

    (31) expr -> case . expr of case_list esac
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 73

state 41

    (32) expr -> new . type

    type            shift and go to state 74


state 42

    (33) expr -> isvoid . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 75

state 43

    (41) expr -> complement . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 76

state 44

    (42) expr -> not . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 77

state 45

    (45) expr -> number .

    semi            reduce using rule 45 (expr -> number .)
    dot             reduce using rule 45 (expr -> number .)
    arroba          reduce using rule 45 (expr -> number .)
    plus            reduce using rule 45 (expr -> number .)
    minus           reduce using rule 45 (expr -> number .)
    star            reduce using rule 45 (expr -> number .)
    div             reduce using rule 45 (expr -> number .)
    equal           reduce using rule 45 (expr -> number .)
    lneq            reduce using rule 45 (expr -> number .)
    leq             reduce using rule 45 (expr -> number .)
    cpar            reduce using rule 45 (expr -> number .)
    then            reduce using rule 45 (expr -> number .)
    loop            reduce using rule 45 (expr -> number .)
    of              reduce using rule 45 (expr -> number .)
    comma           reduce using rule 45 (expr -> number .)
    else            reduce using rule 45 (expr -> number .)
    pool            reduce using rule 45 (expr -> number .)
    ccur            reduce using rule 45 (expr -> number .)
    fi              reduce using rule 45 (expr -> number .)
    in              reduce using rule 45 (expr -> number .)


state 46

    (46) expr -> string .

    semi            reduce using rule 46 (expr -> string .)
    dot             reduce using rule 46 (expr -> string .)
    arroba          reduce using rule 46 (expr -> string .)
    plus            reduce using rule 46 (expr -> string .)
    minus           reduce using rule 46 (expr -> string .)
    star            reduce using rule 46 (expr -> string .)
    div             reduce using rule 46 (expr -> string .)
    equal           reduce using rule 46 (expr -> string .)
    lneq            reduce using rule 46 (expr -> string .)
    leq             reduce using rule 46 (expr -> string .)
    cpar            reduce using rule 46 (expr -> string .)
    then            reduce using rule 46 (expr -> string .)
    loop            reduce using rule 46 (expr -> string .)
    of              reduce using rule 46 (expr -> string .)
    comma           reduce using rule 46 (expr -> string .)
    else            reduce using rule 46 (expr -> string .)
    pool            reduce using rule 46 (expr -> string .)
    ccur            reduce using rule 46 (expr -> string .)
    fi              reduce using rule 46 (expr -> string .)
    in              reduce using rule 46 (expr -> string .)


state 47

    (47) expr -> true .

    semi            reduce using rule 47 (expr -> true .)
    dot             reduce using rule 47 (expr -> true .)
    arroba          reduce using rule 47 (expr -> true .)
    plus            reduce using rule 47 (expr -> true .)
    minus           reduce using rule 47 (expr -> true .)
    star            reduce using rule 47 (expr -> true .)
    div             reduce using rule 47 (expr -> true .)
    equal           reduce using rule 47 (expr -> true .)
    lneq            reduce using rule 47 (expr -> true .)
    leq             reduce using rule 47 (expr -> true .)
    cpar            reduce using rule 47 (expr -> true .)
    then            reduce using rule 47 (expr -> true .)
    loop            reduce using rule 47 (expr -> true .)
    of              reduce using rule 47 (expr -> true .)
    comma           reduce using rule 47 (expr -> true .)
    else            reduce using rule 47 (expr -> true .)
    pool            reduce using rule 47 (expr -> true .)
    ccur            reduce using rule 47 (expr -> true .)
    fi              reduce using rule 47 (expr -> true .)
    in              reduce using rule 47 (expr -> true .)


state 48

    (48) expr -> false .

    semi            reduce using rule 48 (expr -> false .)
    dot             reduce using rule 48 (expr -> false .)
    arroba          reduce using rule 48 (expr -> false .)
    plus            reduce using rule 48 (expr -> false .)
    minus           reduce using rule 48 (expr -> false .)
    star            reduce using rule 48 (expr -> false .)
    div             reduce using rule 48 (expr -> false .)
    equal           reduce using rule 48 (expr -> false .)
    lneq            reduce using rule 48 (expr -> false .)
    leq             reduce using rule 48 (expr -> false .)
    cpar            reduce using rule 48 (expr -> false .)
    then            reduce using rule 48 (expr -> false .)
    loop            reduce using rule 48 (expr -> false .)
    of              reduce using rule 48 (expr -> false .)
    comma           reduce using rule 48 (expr -> false .)
    else            reduce using rule 48 (expr -> false .)
    pool            reduce using rule 48 (expr -> false .)
    ccur            reduce using rule 48 (expr -> false .)
    fi              reduce using rule 48 (expr -> false .)
    in              reduce using rule 48 (expr -> false .)


state 49

    (16) arg -> id colon type .

    comma           reduce using rule 16 (arg -> id colon type .)
    cpar            reduce using rule 16 (arg -> id colon type .)


state 50

    (11) def_func -> id opar arg_list cpar colon . type ocur expr ccur semi

    type            shift and go to state 78


state 51

    (15) non_empty_arg_list -> arg comma non_empty_arg_list .

    cpar            reduce using rule 15 (non_empty_arg_list -> arg comma non_empty_arg_list .)


state 52

    (5) def_class -> class type inherits type ocur feature_list ccur semi .

    class           reduce using rule 5 (def_class -> class type inherits type ocur feature_list ccur semi .)
    $end            reduce using rule 5 (def_class -> class type inherits type ocur feature_list ccur semi .)


state 53

    (23) expr -> id assignArrow . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 79

state 54

    (26) expr -> id opar . param_list cpar
    (17) param_list -> . expr_list
    (18) param_list -> .
    (19) expr_list -> . expr
    (20) expr_list -> . expr comma expr_list
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    cpar            reduce using rule 18 (param_list -> .)
    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    param_list                     shift and go to state 80
    expr_list                      shift and go to state 81
    expr                           shift and go to state 82

state 55

    (10) def_attr -> id colon type assignArrow expr semi .

    id              reduce using rule 10 (def_attr -> id colon type assignArrow expr semi .)
    ccur            reduce using rule 10 (def_attr -> id colon type assignArrow expr semi .)


state 56

    (24) expr -> expr dot . id opar param_list cpar

    id              shift and go to state 83


state 57

    (25) expr -> expr arroba . type dot id opar param_list cpar

    type            shift and go to state 84


state 58

    (34) expr -> expr plus . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 85

state 59

    (35) expr -> expr minus . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 86

state 60

    (36) expr -> expr star . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 87

state 61

    (37) expr -> expr div . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 88

state 62

    (38) expr -> expr equal . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 89

state 63

    (39) expr -> expr lneq . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 90

state 64

    (40) expr -> expr leq . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 91

state 65

    (43) expr -> opar expr . cpar
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    cpar            shift and go to state 92
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 66

    (27) expr -> if expr . then expr else expr fi
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    then            shift and go to state 93
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 67

    (28) expr -> while expr . loop expr pool
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    loop            shift and go to state 94
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 68

    (29) expr -> ocur chunk . ccur

    ccur            shift and go to state 95


state 69

    (21) chunk -> expr . semi
    (22) chunk -> expr . semi chunk
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            shift and go to state 96
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 70

    (30) expr -> let decl_list . in expr

    in              shift and go to state 97


state 71

    (49) decl_list -> decl .
    (50) decl_list -> decl . comma decl_list

    in              reduce using rule 49 (decl_list -> decl .)
    comma           shift and go to state 98


state 72

    (51) decl -> id . colon type
    (52) decl -> id . colon type assignArrow expr

    colon           shift and go to state 99


state 73

    (31) expr -> case expr . of case_list esac
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    of              shift and go to state 100
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 74

    (32) expr -> new type .

    semi            reduce using rule 32 (expr -> new type .)
    dot             reduce using rule 32 (expr -> new type .)
    arroba          reduce using rule 32 (expr -> new type .)
    plus            reduce using rule 32 (expr -> new type .)
    minus           reduce using rule 32 (expr -> new type .)
    star            reduce using rule 32 (expr -> new type .)
    div             reduce using rule 32 (expr -> new type .)
    equal           reduce using rule 32 (expr -> new type .)
    lneq            reduce using rule 32 (expr -> new type .)
    leq             reduce using rule 32 (expr -> new type .)
    cpar            reduce using rule 32 (expr -> new type .)
    then            reduce using rule 32 (expr -> new type .)
    loop            reduce using rule 32 (expr -> new type .)
    of              reduce using rule 32 (expr -> new type .)
    comma           reduce using rule 32 (expr -> new type .)
    else            reduce using rule 32 (expr -> new type .)
    pool            reduce using rule 32 (expr -> new type .)
    ccur            reduce using rule 32 (expr -> new type .)
    fi              reduce using rule 32 (expr -> new type .)
    in              reduce using rule 32 (expr -> new type .)


state 75

    (33) expr -> isvoid expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 33 (expr -> isvoid expr .)
    plus            reduce using rule 33 (expr -> isvoid expr .)
    minus           reduce using rule 33 (expr -> isvoid expr .)
    star            reduce using rule 33 (expr -> isvoid expr .)
    div             reduce using rule 33 (expr -> isvoid expr .)
    equal           reduce using rule 33 (expr -> isvoid expr .)
    lneq            reduce using rule 33 (expr -> isvoid expr .)
    leq             reduce using rule 33 (expr -> isvoid expr .)
    cpar            reduce using rule 33 (expr -> isvoid expr .)
    then            reduce using rule 33 (expr -> isvoid expr .)
    loop            reduce using rule 33 (expr -> isvoid expr .)
    of              reduce using rule 33 (expr -> isvoid expr .)
    comma           reduce using rule 33 (expr -> isvoid expr .)
    else            reduce using rule 33 (expr -> isvoid expr .)
    pool            reduce using rule 33 (expr -> isvoid expr .)
    ccur            reduce using rule 33 (expr -> isvoid expr .)
    fi              reduce using rule 33 (expr -> isvoid expr .)
    in              reduce using rule 33 (expr -> isvoid expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57

  ! dot             [ reduce using rule 33 (expr -> isvoid expr .) ]
  ! arroba          [ reduce using rule 33 (expr -> isvoid expr .) ]
  ! plus            [ shift and go to state 58 ]
  ! minus           [ shift and go to state 59 ]
  ! star            [ shift and go to state 60 ]
  ! div             [ shift and go to state 61 ]
  ! equal           [ shift and go to state 62 ]
  ! lneq            [ shift and go to state 63 ]
  ! leq             [ shift and go to state 64 ]


state 76

    (41) expr -> complement expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 41 (expr -> complement expr .)
    plus            reduce using rule 41 (expr -> complement expr .)
    minus           reduce using rule 41 (expr -> complement expr .)
    star            reduce using rule 41 (expr -> complement expr .)
    div             reduce using rule 41 (expr -> complement expr .)
    equal           reduce using rule 41 (expr -> complement expr .)
    lneq            reduce using rule 41 (expr -> complement expr .)
    leq             reduce using rule 41 (expr -> complement expr .)
    cpar            reduce using rule 41 (expr -> complement expr .)
    then            reduce using rule 41 (expr -> complement expr .)
    loop            reduce using rule 41 (expr -> complement expr .)
    of              reduce using rule 41 (expr -> complement expr .)
    comma           reduce using rule 41 (expr -> complement expr .)
    else            reduce using rule 41 (expr -> complement expr .)
    pool            reduce using rule 41 (expr -> complement expr .)
    ccur            reduce using rule 41 (expr -> complement expr .)
    fi              reduce using rule 41 (expr -> complement expr .)
    in              reduce using rule 41 (expr -> complement expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57

  ! dot             [ reduce using rule 41 (expr -> complement expr .) ]
  ! arroba          [ reduce using rule 41 (expr -> complement expr .) ]
  ! plus            [ shift and go to state 58 ]
  ! minus           [ shift and go to state 59 ]
  ! star            [ shift and go to state 60 ]
  ! div             [ shift and go to state 61 ]
  ! equal           [ shift and go to state 62 ]
  ! lneq            [ shift and go to state 63 ]
  ! leq             [ shift and go to state 64 ]


state 77

    (42) expr -> not expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 42 (expr -> not expr .)
    cpar            reduce using rule 42 (expr -> not expr .)
    then            reduce using rule 42 (expr -> not expr .)
    loop            reduce using rule 42 (expr -> not expr .)
    of              reduce using rule 42 (expr -> not expr .)
    comma           reduce using rule 42 (expr -> not expr .)
    else            reduce using rule 42 (expr -> not expr .)
    pool            reduce using rule 42 (expr -> not expr .)
    ccur            reduce using rule 42 (expr -> not expr .)
    fi              reduce using rule 42 (expr -> not expr .)
    in              reduce using rule 42 (expr -> not expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64

  ! dot             [ reduce using rule 42 (expr -> not expr .) ]
  ! arroba          [ reduce using rule 42 (expr -> not expr .) ]
  ! plus            [ reduce using rule 42 (expr -> not expr .) ]
  ! minus           [ reduce using rule 42 (expr -> not expr .) ]
  ! star            [ reduce using rule 42 (expr -> not expr .) ]
  ! div             [ reduce using rule 42 (expr -> not expr .) ]
  ! equal           [ reduce using rule 42 (expr -> not expr .) ]
  ! lneq            [ reduce using rule 42 (expr -> not expr .) ]
  ! leq             [ reduce using rule 42 (expr -> not expr .) ]


state 78

    (11) def_func -> id opar arg_list cpar colon type . ocur expr ccur semi

    ocur            shift and go to state 101


state 79

    (23) expr -> id assignArrow expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 23 (expr -> id assignArrow expr .)
    cpar            reduce using rule 23 (expr -> id assignArrow expr .)
    then            reduce using rule 23 (expr -> id assignArrow expr .)
    loop            reduce using rule 23 (expr -> id assignArrow expr .)
    of              reduce using rule 23 (expr -> id assignArrow expr .)
    comma           reduce using rule 23 (expr -> id assignArrow expr .)
    else            reduce using rule 23 (expr -> id assignArrow expr .)
    pool            reduce using rule 23 (expr -> id assignArrow expr .)
    ccur            reduce using rule 23 (expr -> id assignArrow expr .)
    fi              reduce using rule 23 (expr -> id assignArrow expr .)
    in              reduce using rule 23 (expr -> id assignArrow expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64

  ! dot             [ reduce using rule 23 (expr -> id assignArrow expr .) ]
  ! arroba          [ reduce using rule 23 (expr -> id assignArrow expr .) ]
  ! plus            [ reduce using rule 23 (expr -> id assignArrow expr .) ]
  ! minus           [ reduce using rule 23 (expr -> id assignArrow expr .) ]
  ! star            [ reduce using rule 23 (expr -> id assignArrow expr .) ]
  ! div             [ reduce using rule 23 (expr -> id assignArrow expr .) ]
  ! equal           [ reduce using rule 23 (expr -> id assignArrow expr .) ]
  ! lneq            [ reduce using rule 23 (expr -> id assignArrow expr .) ]
  ! leq             [ reduce using rule 23 (expr -> id assignArrow expr .) ]


state 80

    (26) expr -> id opar param_list . cpar

    cpar            shift and go to state 102


state 81

    (17) param_list -> expr_list .

    cpar            reduce using rule 17 (param_list -> expr_list .)


state 82

    (19) expr_list -> expr .
    (20) expr_list -> expr . comma expr_list
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    cpar            reduce using rule 19 (expr_list -> expr .)
    comma           shift and go to state 103
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 83

    (24) expr -> expr dot id . opar param_list cpar

    opar            shift and go to state 104


state 84

    (25) expr -> expr arroba type . dot id opar param_list cpar

    dot             shift and go to state 105


state 85

    (34) expr -> expr plus expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 34 (expr -> expr plus expr .)
    plus            reduce using rule 34 (expr -> expr plus expr .)
    minus           reduce using rule 34 (expr -> expr plus expr .)
    equal           reduce using rule 34 (expr -> expr plus expr .)
    lneq            reduce using rule 34 (expr -> expr plus expr .)
    leq             reduce using rule 34 (expr -> expr plus expr .)
    cpar            reduce using rule 34 (expr -> expr plus expr .)
    then            reduce using rule 34 (expr -> expr plus expr .)
    loop            reduce using rule 34 (expr -> expr plus expr .)
    of              reduce using rule 34 (expr -> expr plus expr .)
    comma           reduce using rule 34 (expr -> expr plus expr .)
    else            reduce using rule 34 (expr -> expr plus expr .)
    pool            reduce using rule 34 (expr -> expr plus expr .)
    ccur            reduce using rule 34 (expr -> expr plus expr .)
    fi              reduce using rule 34 (expr -> expr plus expr .)
    in              reduce using rule 34 (expr -> expr plus expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57
    star            shift and go to state 60
    div             shift and go to state 61

  ! dot             [ reduce using rule 34 (expr -> expr plus expr .) ]
  ! arroba          [ reduce using rule 34 (expr -> expr plus expr .) ]
  ! star            [ reduce using rule 34 (expr -> expr plus expr .) ]
  ! div             [ reduce using rule 34 (expr -> expr plus expr .) ]
  ! plus            [ shift and go to state 58 ]
  ! minus           [ shift and go to state 59 ]
  ! equal           [ shift and go to state 62 ]
  ! lneq            [ shift and go to state 63 ]
  ! leq             [ shift and go to state 64 ]


state 86

    (35) expr -> expr minus expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 35 (expr -> expr minus expr .)
    plus            reduce using rule 35 (expr -> expr minus expr .)
    minus           reduce using rule 35 (expr -> expr minus expr .)
    equal           reduce using rule 35 (expr -> expr minus expr .)
    lneq            reduce using rule 35 (expr -> expr minus expr .)
    leq             reduce using rule 35 (expr -> expr minus expr .)
    cpar            reduce using rule 35 (expr -> expr minus expr .)
    then            reduce using rule 35 (expr -> expr minus expr .)
    loop            reduce using rule 35 (expr -> expr minus expr .)
    of              reduce using rule 35 (expr -> expr minus expr .)
    comma           reduce using rule 35 (expr -> expr minus expr .)
    else            reduce using rule 35 (expr -> expr minus expr .)
    pool            reduce using rule 35 (expr -> expr minus expr .)
    ccur            reduce using rule 35 (expr -> expr minus expr .)
    fi              reduce using rule 35 (expr -> expr minus expr .)
    in              reduce using rule 35 (expr -> expr minus expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57
    star            shift and go to state 60
    div             shift and go to state 61

  ! dot             [ reduce using rule 35 (expr -> expr minus expr .) ]
  ! arroba          [ reduce using rule 35 (expr -> expr minus expr .) ]
  ! star            [ reduce using rule 35 (expr -> expr minus expr .) ]
  ! div             [ reduce using rule 35 (expr -> expr minus expr .) ]
  ! plus            [ shift and go to state 58 ]
  ! minus           [ shift and go to state 59 ]
  ! equal           [ shift and go to state 62 ]
  ! lneq            [ shift and go to state 63 ]
  ! leq             [ shift and go to state 64 ]


state 87

    (36) expr -> expr star expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 36 (expr -> expr star expr .)
    plus            reduce using rule 36 (expr -> expr star expr .)
    minus           reduce using rule 36 (expr -> expr star expr .)
    star            reduce using rule 36 (expr -> expr star expr .)
    div             reduce using rule 36 (expr -> expr star expr .)
    equal           reduce using rule 36 (expr -> expr star expr .)
    lneq            reduce using rule 36 (expr -> expr star expr .)
    leq             reduce using rule 36 (expr -> expr star expr .)
    cpar            reduce using rule 36 (expr -> expr star expr .)
    then            reduce using rule 36 (expr -> expr star expr .)
    loop            reduce using rule 36 (expr -> expr star expr .)
    of              reduce using rule 36 (expr -> expr star expr .)
    comma           reduce using rule 36 (expr -> expr star expr .)
    else            reduce using rule 36 (expr -> expr star expr .)
    pool            reduce using rule 36 (expr -> expr star expr .)
    ccur            reduce using rule 36 (expr -> expr star expr .)
    fi              reduce using rule 36 (expr -> expr star expr .)
    in              reduce using rule 36 (expr -> expr star expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57

  ! dot             [ reduce using rule 36 (expr -> expr star expr .) ]
  ! arroba          [ reduce using rule 36 (expr -> expr star expr .) ]
  ! plus            [ shift and go to state 58 ]
  ! minus           [ shift and go to state 59 ]
  ! star            [ shift and go to state 60 ]
  ! div             [ shift and go to state 61 ]
  ! equal           [ shift and go to state 62 ]
  ! lneq            [ shift and go to state 63 ]
  ! leq             [ shift and go to state 64 ]


state 88

    (37) expr -> expr div expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 37 (expr -> expr div expr .)
    plus            reduce using rule 37 (expr -> expr div expr .)
    minus           reduce using rule 37 (expr -> expr div expr .)
    star            reduce using rule 37 (expr -> expr div expr .)
    div             reduce using rule 37 (expr -> expr div expr .)
    equal           reduce using rule 37 (expr -> expr div expr .)
    lneq            reduce using rule 37 (expr -> expr div expr .)
    leq             reduce using rule 37 (expr -> expr div expr .)
    cpar            reduce using rule 37 (expr -> expr div expr .)
    then            reduce using rule 37 (expr -> expr div expr .)
    loop            reduce using rule 37 (expr -> expr div expr .)
    of              reduce using rule 37 (expr -> expr div expr .)
    comma           reduce using rule 37 (expr -> expr div expr .)
    else            reduce using rule 37 (expr -> expr div expr .)
    pool            reduce using rule 37 (expr -> expr div expr .)
    ccur            reduce using rule 37 (expr -> expr div expr .)
    fi              reduce using rule 37 (expr -> expr div expr .)
    in              reduce using rule 37 (expr -> expr div expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57

  ! dot             [ reduce using rule 37 (expr -> expr div expr .) ]
  ! arroba          [ reduce using rule 37 (expr -> expr div expr .) ]
  ! plus            [ shift and go to state 58 ]
  ! minus           [ shift and go to state 59 ]
  ! star            [ shift and go to state 60 ]
  ! div             [ shift and go to state 61 ]
  ! equal           [ shift and go to state 62 ]
  ! lneq            [ shift and go to state 63 ]
  ! leq             [ shift and go to state 64 ]


state 89

    (38) expr -> expr equal expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 38 (expr -> expr equal expr .)
    equal           reduce using rule 38 (expr -> expr equal expr .)
    lneq            reduce using rule 38 (expr -> expr equal expr .)
    leq             reduce using rule 38 (expr -> expr equal expr .)
    cpar            reduce using rule 38 (expr -> expr equal expr .)
    then            reduce using rule 38 (expr -> expr equal expr .)
    loop            reduce using rule 38 (expr -> expr equal expr .)
    of              reduce using rule 38 (expr -> expr equal expr .)
    comma           reduce using rule 38 (expr -> expr equal expr .)
    else            reduce using rule 38 (expr -> expr equal expr .)
    pool            reduce using rule 38 (expr -> expr equal expr .)
    ccur            reduce using rule 38 (expr -> expr equal expr .)
    fi              reduce using rule 38 (expr -> expr equal expr .)
    in              reduce using rule 38 (expr -> expr equal expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61

  ! dot             [ reduce using rule 38 (expr -> expr equal expr .) ]
  ! arroba          [ reduce using rule 38 (expr -> expr equal expr .) ]
  ! plus            [ reduce using rule 38 (expr -> expr equal expr .) ]
  ! minus           [ reduce using rule 38 (expr -> expr equal expr .) ]
  ! star            [ reduce using rule 38 (expr -> expr equal expr .) ]
  ! div             [ reduce using rule 38 (expr -> expr equal expr .) ]
  ! equal           [ shift and go to state 62 ]
  ! lneq            [ shift and go to state 63 ]
  ! leq             [ shift and go to state 64 ]


state 90

    (39) expr -> expr lneq expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 39 (expr -> expr lneq expr .)
    equal           reduce using rule 39 (expr -> expr lneq expr .)
    lneq            reduce using rule 39 (expr -> expr lneq expr .)
    leq             reduce using rule 39 (expr -> expr lneq expr .)
    cpar            reduce using rule 39 (expr -> expr lneq expr .)
    then            reduce using rule 39 (expr -> expr lneq expr .)
    loop            reduce using rule 39 (expr -> expr lneq expr .)
    of              reduce using rule 39 (expr -> expr lneq expr .)
    comma           reduce using rule 39 (expr -> expr lneq expr .)
    else            reduce using rule 39 (expr -> expr lneq expr .)
    pool            reduce using rule 39 (expr -> expr lneq expr .)
    ccur            reduce using rule 39 (expr -> expr lneq expr .)
    fi              reduce using rule 39 (expr -> expr lneq expr .)
    in              reduce using rule 39 (expr -> expr lneq expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61

  ! dot             [ reduce using rule 39 (expr -> expr lneq expr .) ]
  ! arroba          [ reduce using rule 39 (expr -> expr lneq expr .) ]
  ! plus            [ reduce using rule 39 (expr -> expr lneq expr .) ]
  ! minus           [ reduce using rule 39 (expr -> expr lneq expr .) ]
  ! star            [ reduce using rule 39 (expr -> expr lneq expr .) ]
  ! div             [ reduce using rule 39 (expr -> expr lneq expr .) ]
  ! equal           [ shift and go to state 62 ]
  ! lneq            [ shift and go to state 63 ]
  ! leq             [ shift and go to state 64 ]


state 91

    (40) expr -> expr leq expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            reduce using rule 40 (expr -> expr leq expr .)
    equal           reduce using rule 40 (expr -> expr leq expr .)
    lneq            reduce using rule 40 (expr -> expr leq expr .)
    leq             reduce using rule 40 (expr -> expr leq expr .)
    cpar            reduce using rule 40 (expr -> expr leq expr .)
    then            reduce using rule 40 (expr -> expr leq expr .)
    loop            reduce using rule 40 (expr -> expr leq expr .)
    of              reduce using rule 40 (expr -> expr leq expr .)
    comma           reduce using rule 40 (expr -> expr leq expr .)
    else            reduce using rule 40 (expr -> expr leq expr .)
    pool            reduce using rule 40 (expr -> expr leq expr .)
    ccur            reduce using rule 40 (expr -> expr leq expr .)
    fi              reduce using rule 40 (expr -> expr leq expr .)
    in              reduce using rule 40 (expr -> expr leq expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61

  ! dot             [ reduce using rule 40 (expr -> expr leq expr .) ]
  ! arroba          [ reduce using rule 40 (expr -> expr leq expr .) ]
  ! plus            [ reduce using rule 40 (expr -> expr leq expr .) ]
  ! minus           [ reduce using rule 40 (expr -> expr leq expr .) ]
  ! star            [ reduce using rule 40 (expr -> expr leq expr .) ]
  ! div             [ reduce using rule 40 (expr -> expr leq expr .) ]
  ! equal           [ shift and go to state 62 ]
  ! lneq            [ shift and go to state 63 ]
  ! leq             [ shift and go to state 64 ]


state 92

    (43) expr -> opar expr cpar .

    semi            reduce using rule 43 (expr -> opar expr cpar .)
    dot             reduce using rule 43 (expr -> opar expr cpar .)
    arroba          reduce using rule 43 (expr -> opar expr cpar .)
    plus            reduce using rule 43 (expr -> opar expr cpar .)
    minus           reduce using rule 43 (expr -> opar expr cpar .)
    star            reduce using rule 43 (expr -> opar expr cpar .)
    div             reduce using rule 43 (expr -> opar expr cpar .)
    equal           reduce using rule 43 (expr -> opar expr cpar .)
    lneq            reduce using rule 43 (expr -> opar expr cpar .)
    leq             reduce using rule 43 (expr -> opar expr cpar .)
    cpar            reduce using rule 43 (expr -> opar expr cpar .)
    then            reduce using rule 43 (expr -> opar expr cpar .)
    loop            reduce using rule 43 (expr -> opar expr cpar .)
    of              reduce using rule 43 (expr -> opar expr cpar .)
    comma           reduce using rule 43 (expr -> opar expr cpar .)
    else            reduce using rule 43 (expr -> opar expr cpar .)
    pool            reduce using rule 43 (expr -> opar expr cpar .)
    ccur            reduce using rule 43 (expr -> opar expr cpar .)
    fi              reduce using rule 43 (expr -> opar expr cpar .)
    in              reduce using rule 43 (expr -> opar expr cpar .)


state 93

    (27) expr -> if expr then . expr else expr fi
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 106

state 94

    (28) expr -> while expr loop . expr pool
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 107

state 95

    (29) expr -> ocur chunk ccur .

    semi            reduce using rule 29 (expr -> ocur chunk ccur .)
    dot             reduce using rule 29 (expr -> ocur chunk ccur .)
    arroba          reduce using rule 29 (expr -> ocur chunk ccur .)
    plus            reduce using rule 29 (expr -> ocur chunk ccur .)
    minus           reduce using rule 29 (expr -> ocur chunk ccur .)
    star            reduce using rule 29 (expr -> ocur chunk ccur .)
    div             reduce using rule 29 (expr -> ocur chunk ccur .)
    equal           reduce using rule 29 (expr -> ocur chunk ccur .)
    lneq            reduce using rule 29 (expr -> ocur chunk ccur .)
    leq             reduce using rule 29 (expr -> ocur chunk ccur .)
    cpar            reduce using rule 29 (expr -> ocur chunk ccur .)
    then            reduce using rule 29 (expr -> ocur chunk ccur .)
    loop            reduce using rule 29 (expr -> ocur chunk ccur .)
    of              reduce using rule 29 (expr -> ocur chunk ccur .)
    comma           reduce using rule 29 (expr -> ocur chunk ccur .)
    else            reduce using rule 29 (expr -> ocur chunk ccur .)
    pool            reduce using rule 29 (expr -> ocur chunk ccur .)
    ccur            reduce using rule 29 (expr -> ocur chunk ccur .)
    fi              reduce using rule 29 (expr -> ocur chunk ccur .)
    in              reduce using rule 29 (expr -> ocur chunk ccur .)


state 96

    (21) chunk -> expr semi .
    (22) chunk -> expr semi . chunk
    (21) chunk -> . expr semi
    (22) chunk -> . expr semi chunk
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    ccur            reduce using rule 21 (chunk -> expr semi .)
    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 69
    chunk                          shift and go to state 108

state 97

    (30) expr -> let decl_list in . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 109

state 98

    (50) decl_list -> decl comma . decl_list
    (49) decl_list -> . decl
    (50) decl_list -> . decl comma decl_list
    (51) decl -> . id colon type
    (52) decl -> . id colon type assignArrow expr

    id              shift and go to state 72

    decl                           shift and go to state 71
    decl_list                      shift and go to state 110

state 99

    (51) decl -> id colon . type
    (52) decl -> id colon . type assignArrow expr

    type            shift and go to state 111


state 100

    (31) expr -> case expr of . case_list esac
    (53) case_list -> . id colon type rArrow expr semi
    (54) case_list -> . id colon type rArrow expr semi case_list

    id              shift and go to state 113

    case_list                      shift and go to state 112

state 101

    (11) def_func -> id opar arg_list cpar colon type ocur . expr ccur semi
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 114

state 102

    (26) expr -> id opar param_list cpar .

    semi            reduce using rule 26 (expr -> id opar param_list cpar .)
    dot             reduce using rule 26 (expr -> id opar param_list cpar .)
    arroba          reduce using rule 26 (expr -> id opar param_list cpar .)
    plus            reduce using rule 26 (expr -> id opar param_list cpar .)
    minus           reduce using rule 26 (expr -> id opar param_list cpar .)
    star            reduce using rule 26 (expr -> id opar param_list cpar .)
    div             reduce using rule 26 (expr -> id opar param_list cpar .)
    equal           reduce using rule 26 (expr -> id opar param_list cpar .)
    lneq            reduce using rule 26 (expr -> id opar param_list cpar .)
    leq             reduce using rule 26 (expr -> id opar param_list cpar .)
    cpar            reduce using rule 26 (expr -> id opar param_list cpar .)
    then            reduce using rule 26 (expr -> id opar param_list cpar .)
    loop            reduce using rule 26 (expr -> id opar param_list cpar .)
    of              reduce using rule 26 (expr -> id opar param_list cpar .)
    comma           reduce using rule 26 (expr -> id opar param_list cpar .)
    else            reduce using rule 26 (expr -> id opar param_list cpar .)
    pool            reduce using rule 26 (expr -> id opar param_list cpar .)
    ccur            reduce using rule 26 (expr -> id opar param_list cpar .)
    fi              reduce using rule 26 (expr -> id opar param_list cpar .)
    in              reduce using rule 26 (expr -> id opar param_list cpar .)


state 103

    (20) expr_list -> expr comma . expr_list
    (19) expr_list -> . expr
    (20) expr_list -> . expr comma expr_list
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 82
    expr_list                      shift and go to state 115

state 104

    (24) expr -> expr dot id opar . param_list cpar
    (17) param_list -> . expr_list
    (18) param_list -> .
    (19) expr_list -> . expr
    (20) expr_list -> . expr comma expr_list
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    cpar            reduce using rule 18 (param_list -> .)
    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 82
    param_list                     shift and go to state 116
    expr_list                      shift and go to state 81

state 105

    (25) expr -> expr arroba type dot . id opar param_list cpar

    id              shift and go to state 117


state 106

    (27) expr -> if expr then expr . else expr fi
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    else            shift and go to state 118
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 107

    (28) expr -> while expr loop expr . pool
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    pool            shift and go to state 119
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 108

    (22) chunk -> expr semi chunk .

    ccur            reduce using rule 22 (chunk -> expr semi chunk .)


state 109

    (30) expr -> let decl_list in expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for arroba resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for star resolved as shift
  ! shift/reduce conflict for div resolved as shift
  ! shift/reduce conflict for equal resolved as shift
  ! shift/reduce conflict for lneq resolved as shift
  ! shift/reduce conflict for leq resolved as shift
    semi            reduce using rule 30 (expr -> let decl_list in expr .)
    cpar            reduce using rule 30 (expr -> let decl_list in expr .)
    then            reduce using rule 30 (expr -> let decl_list in expr .)
    loop            reduce using rule 30 (expr -> let decl_list in expr .)
    of              reduce using rule 30 (expr -> let decl_list in expr .)
    comma           reduce using rule 30 (expr -> let decl_list in expr .)
    else            reduce using rule 30 (expr -> let decl_list in expr .)
    pool            reduce using rule 30 (expr -> let decl_list in expr .)
    ccur            reduce using rule 30 (expr -> let decl_list in expr .)
    fi              reduce using rule 30 (expr -> let decl_list in expr .)
    in              reduce using rule 30 (expr -> let decl_list in expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64

  ! dot             [ reduce using rule 30 (expr -> let decl_list in expr .) ]
  ! arroba          [ reduce using rule 30 (expr -> let decl_list in expr .) ]
  ! plus            [ reduce using rule 30 (expr -> let decl_list in expr .) ]
  ! minus           [ reduce using rule 30 (expr -> let decl_list in expr .) ]
  ! star            [ reduce using rule 30 (expr -> let decl_list in expr .) ]
  ! div             [ reduce using rule 30 (expr -> let decl_list in expr .) ]
  ! equal           [ reduce using rule 30 (expr -> let decl_list in expr .) ]
  ! lneq            [ reduce using rule 30 (expr -> let decl_list in expr .) ]
  ! leq             [ reduce using rule 30 (expr -> let decl_list in expr .) ]


state 110

    (50) decl_list -> decl comma decl_list .

    in              reduce using rule 50 (decl_list -> decl comma decl_list .)


state 111

    (51) decl -> id colon type .
    (52) decl -> id colon type . assignArrow expr

    comma           reduce using rule 51 (decl -> id colon type .)
    in              reduce using rule 51 (decl -> id colon type .)
    assignArrow     shift and go to state 120


state 112

    (31) expr -> case expr of case_list . esac

    esac            shift and go to state 121


state 113

    (53) case_list -> id . colon type rArrow expr semi
    (54) case_list -> id . colon type rArrow expr semi case_list

    colon           shift and go to state 122


state 114

    (11) def_func -> id opar arg_list cpar colon type ocur expr . ccur semi
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    ccur            shift and go to state 123
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 115

    (20) expr_list -> expr comma expr_list .

    cpar            reduce using rule 20 (expr_list -> expr comma expr_list .)


state 116

    (24) expr -> expr dot id opar param_list . cpar

    cpar            shift and go to state 124


state 117

    (25) expr -> expr arroba type dot id . opar param_list cpar

    opar            shift and go to state 125


state 118

    (27) expr -> if expr then expr else . expr fi
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 126

state 119

    (28) expr -> while expr loop expr pool .

    semi            reduce using rule 28 (expr -> while expr loop expr pool .)
    dot             reduce using rule 28 (expr -> while expr loop expr pool .)
    arroba          reduce using rule 28 (expr -> while expr loop expr pool .)
    plus            reduce using rule 28 (expr -> while expr loop expr pool .)
    minus           reduce using rule 28 (expr -> while expr loop expr pool .)
    star            reduce using rule 28 (expr -> while expr loop expr pool .)
    div             reduce using rule 28 (expr -> while expr loop expr pool .)
    equal           reduce using rule 28 (expr -> while expr loop expr pool .)
    lneq            reduce using rule 28 (expr -> while expr loop expr pool .)
    leq             reduce using rule 28 (expr -> while expr loop expr pool .)
    cpar            reduce using rule 28 (expr -> while expr loop expr pool .)
    then            reduce using rule 28 (expr -> while expr loop expr pool .)
    loop            reduce using rule 28 (expr -> while expr loop expr pool .)
    of              reduce using rule 28 (expr -> while expr loop expr pool .)
    comma           reduce using rule 28 (expr -> while expr loop expr pool .)
    else            reduce using rule 28 (expr -> while expr loop expr pool .)
    pool            reduce using rule 28 (expr -> while expr loop expr pool .)
    ccur            reduce using rule 28 (expr -> while expr loop expr pool .)
    fi              reduce using rule 28 (expr -> while expr loop expr pool .)
    in              reduce using rule 28 (expr -> while expr loop expr pool .)


state 120

    (52) decl -> id colon type assignArrow . expr
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 127

state 121

    (31) expr -> case expr of case_list esac .

    semi            reduce using rule 31 (expr -> case expr of case_list esac .)
    dot             reduce using rule 31 (expr -> case expr of case_list esac .)
    arroba          reduce using rule 31 (expr -> case expr of case_list esac .)
    plus            reduce using rule 31 (expr -> case expr of case_list esac .)
    minus           reduce using rule 31 (expr -> case expr of case_list esac .)
    star            reduce using rule 31 (expr -> case expr of case_list esac .)
    div             reduce using rule 31 (expr -> case expr of case_list esac .)
    equal           reduce using rule 31 (expr -> case expr of case_list esac .)
    lneq            reduce using rule 31 (expr -> case expr of case_list esac .)
    leq             reduce using rule 31 (expr -> case expr of case_list esac .)
    cpar            reduce using rule 31 (expr -> case expr of case_list esac .)
    then            reduce using rule 31 (expr -> case expr of case_list esac .)
    loop            reduce using rule 31 (expr -> case expr of case_list esac .)
    of              reduce using rule 31 (expr -> case expr of case_list esac .)
    comma           reduce using rule 31 (expr -> case expr of case_list esac .)
    else            reduce using rule 31 (expr -> case expr of case_list esac .)
    pool            reduce using rule 31 (expr -> case expr of case_list esac .)
    ccur            reduce using rule 31 (expr -> case expr of case_list esac .)
    fi              reduce using rule 31 (expr -> case expr of case_list esac .)
    in              reduce using rule 31 (expr -> case expr of case_list esac .)


state 122

    (53) case_list -> id colon . type rArrow expr semi
    (54) case_list -> id colon . type rArrow expr semi case_list

    type            shift and go to state 128


state 123

    (11) def_func -> id opar arg_list cpar colon type ocur expr ccur . semi

    semi            shift and go to state 129


state 124

    (24) expr -> expr dot id opar param_list cpar .

    semi            reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    dot             reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    arroba          reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    plus            reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    minus           reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    star            reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    div             reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    equal           reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    lneq            reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    leq             reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    cpar            reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    then            reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    loop            reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    of              reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    comma           reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    else            reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    pool            reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    ccur            reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    fi              reduce using rule 24 (expr -> expr dot id opar param_list cpar .)
    in              reduce using rule 24 (expr -> expr dot id opar param_list cpar .)


state 125

    (25) expr -> expr arroba type dot id opar . param_list cpar
    (17) param_list -> . expr_list
    (18) param_list -> .
    (19) expr_list -> . expr
    (20) expr_list -> . expr comma expr_list
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    cpar            reduce using rule 18 (param_list -> .)
    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 82
    param_list                     shift and go to state 130
    expr_list                      shift and go to state 81

state 126

    (27) expr -> if expr then expr else expr . fi
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    fi              shift and go to state 131
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 127

    (52) decl -> id colon type assignArrow expr .
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    comma           reduce using rule 52 (decl -> id colon type assignArrow expr .)
    in              reduce using rule 52 (decl -> id colon type assignArrow expr .)
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 128

    (53) case_list -> id colon type . rArrow expr semi
    (54) case_list -> id colon type . rArrow expr semi case_list

    rArrow          shift and go to state 132


state 129

    (11) def_func -> id opar arg_list cpar colon type ocur expr ccur semi .

    id              reduce using rule 11 (def_func -> id opar arg_list cpar colon type ocur expr ccur semi .)
    ccur            reduce using rule 11 (def_func -> id opar arg_list cpar colon type ocur expr ccur semi .)


state 130

    (25) expr -> expr arroba type dot id opar param_list . cpar

    cpar            shift and go to state 133


state 131

    (27) expr -> if expr then expr else expr fi .

    semi            reduce using rule 27 (expr -> if expr then expr else expr fi .)
    dot             reduce using rule 27 (expr -> if expr then expr else expr fi .)
    arroba          reduce using rule 27 (expr -> if expr then expr else expr fi .)
    plus            reduce using rule 27 (expr -> if expr then expr else expr fi .)
    minus           reduce using rule 27 (expr -> if expr then expr else expr fi .)
    star            reduce using rule 27 (expr -> if expr then expr else expr fi .)
    div             reduce using rule 27 (expr -> if expr then expr else expr fi .)
    equal           reduce using rule 27 (expr -> if expr then expr else expr fi .)
    lneq            reduce using rule 27 (expr -> if expr then expr else expr fi .)
    leq             reduce using rule 27 (expr -> if expr then expr else expr fi .)
    cpar            reduce using rule 27 (expr -> if expr then expr else expr fi .)
    then            reduce using rule 27 (expr -> if expr then expr else expr fi .)
    loop            reduce using rule 27 (expr -> if expr then expr else expr fi .)
    of              reduce using rule 27 (expr -> if expr then expr else expr fi .)
    comma           reduce using rule 27 (expr -> if expr then expr else expr fi .)
    else            reduce using rule 27 (expr -> if expr then expr else expr fi .)
    pool            reduce using rule 27 (expr -> if expr then expr else expr fi .)
    ccur            reduce using rule 27 (expr -> if expr then expr else expr fi .)
    fi              reduce using rule 27 (expr -> if expr then expr else expr fi .)
    in              reduce using rule 27 (expr -> if expr then expr else expr fi .)


state 132

    (53) case_list -> id colon type rArrow . expr semi
    (54) case_list -> id colon type rArrow . expr semi case_list
    (23) expr -> . id assignArrow expr
    (24) expr -> . expr dot id opar param_list cpar
    (25) expr -> . expr arroba type dot id opar param_list cpar
    (26) expr -> . id opar param_list cpar
    (27) expr -> . if expr then expr else expr fi
    (28) expr -> . while expr loop expr pool
    (29) expr -> . ocur chunk ccur
    (30) expr -> . let decl_list in expr
    (31) expr -> . case expr of case_list esac
    (32) expr -> . new type
    (33) expr -> . isvoid expr
    (34) expr -> . expr plus expr
    (35) expr -> . expr minus expr
    (36) expr -> . expr star expr
    (37) expr -> . expr div expr
    (38) expr -> . expr equal expr
    (39) expr -> . expr lneq expr
    (40) expr -> . expr leq expr
    (41) expr -> . complement expr
    (42) expr -> . not expr
    (43) expr -> . opar expr cpar
    (44) expr -> . id
    (45) expr -> . number
    (46) expr -> . string
    (47) expr -> . true
    (48) expr -> . false

    id              shift and go to state 33
    if              shift and go to state 36
    while           shift and go to state 37
    ocur            shift and go to state 38
    let             shift and go to state 39
    case            shift and go to state 40
    new             shift and go to state 41
    isvoid          shift and go to state 42
    complement      shift and go to state 43
    not             shift and go to state 44
    opar            shift and go to state 35
    number          shift and go to state 45
    string          shift and go to state 46
    true            shift and go to state 47
    false           shift and go to state 48

    expr                           shift and go to state 134

state 133

    (25) expr -> expr arroba type dot id opar param_list cpar .

    semi            reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    dot             reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    arroba          reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    plus            reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    minus           reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    star            reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    div             reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    equal           reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    lneq            reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    leq             reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    cpar            reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    then            reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    loop            reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    of              reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    comma           reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    else            reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    pool            reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    ccur            reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    fi              reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)
    in              reduce using rule 25 (expr -> expr arroba type dot id opar param_list cpar .)


state 134

    (53) case_list -> id colon type rArrow expr . semi
    (54) case_list -> id colon type rArrow expr . semi case_list
    (24) expr -> expr . dot id opar param_list cpar
    (25) expr -> expr . arroba type dot id opar param_list cpar
    (34) expr -> expr . plus expr
    (35) expr -> expr . minus expr
    (36) expr -> expr . star expr
    (37) expr -> expr . div expr
    (38) expr -> expr . equal expr
    (39) expr -> expr . lneq expr
    (40) expr -> expr . leq expr

    semi            shift and go to state 135
    dot             shift and go to state 56
    arroba          shift and go to state 57
    plus            shift and go to state 58
    minus           shift and go to state 59
    star            shift and go to state 60
    div             shift and go to state 61
    equal           shift and go to state 62
    lneq            shift and go to state 63
    leq             shift and go to state 64


state 135

    (53) case_list -> id colon type rArrow expr semi .
    (54) case_list -> id colon type rArrow expr semi . case_list
    (53) case_list -> . id colon type rArrow expr semi
    (54) case_list -> . id colon type rArrow expr semi case_list

    esac            reduce using rule 53 (case_list -> id colon type rArrow expr semi .)
    id              shift and go to state 113

    case_list                      shift and go to state 136

state 136

    (54) case_list -> id colon type rArrow expr semi case_list .

    esac            reduce using rule 54 (case_list -> id colon type rArrow expr semi case_list .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for dot in state 109 resolved as shift
WARNING: shift/reduce conflict for arroba in state 109 resolved as shift
WARNING: shift/reduce conflict for plus in state 109 resolved as shift
WARNING: shift/reduce conflict for minus in state 109 resolved as shift
WARNING: shift/reduce conflict for star in state 109 resolved as shift
WARNING: shift/reduce conflict for div in state 109 resolved as shift
WARNING: shift/reduce conflict for equal in state 109 resolved as shift
WARNING: shift/reduce conflict for lneq in state 109 resolved as shift
WARNING: shift/reduce conflict for leq in state 109 resolved as shift
